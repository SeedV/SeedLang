# Byte code

The Byte code of Seed is generated from the SeedIR code, and executed by the
SeedInterpreter as a virtual machine. The byte code instructions are 32 bits in
length. All instructions have an opcode in the first 7 bits, so there are at
most 128 kinds of opcode. Other fields of the instructions are listed below:

- A (8 bits): The operand A
- B (8 bits): The operand B
- C (8 bits): The operand C
- K (1 bit): Indicates if the operand C is the index of the register (K = 0) or
  constant (K = 1)
- Bx (17 bits): The operand Bx, combined with B, C and K
- sBx (17 bits): The operand sBx, A signed argument in the range of [-Max, Max)
  (Max = 2 ^ 16). The actual value is the unsigned value (Bx) minus Max, so that
  -Max is represented by 0, and Max - 1 is represented by 2 \* Max - 1.

The layout of the instructions is illustrated as below:

```text

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    |K|      C (8)    |      B (8)    |     A (8)     |   Op (7)    |
    |             Bx (17)             |     A (8)     |   Op (7)    |
    |            sBx (17)             |     A (8)     |   Op (7)    |

```

SeedInterpreter is a register based virtual machine. There are maximum 255
registers for each function. The local variables of a function is pre-allocated
in the registers by the compiler. So the user could not define more than 255
local variables for a certain function.

Each function has its own constant list, which is generated by the compiler. The
elements in the constant list are usually numbers and strings without
duplication.

## Instruction Notation

Following notations are used to explain the behavior of the instructions.

- PC: Program Counter
- R[A]: Register at index A
- R[B]: Register at index B
- R[C]: Register at index C
- K[N]: Element N in the constant list
- RK[C]: Register at index C (when K = 0) or constant at index C (K = 1)

## Move Instruction

```text
Move A B            // R[A] := R[B]
```

Copy the value of the register R[B] into register R[A]. If R[B] holds a object,
the reference to that object is copied. Move is often used for moving values
into place for the next operation.

## LoadI Instruction

```text
LoadI A sBx         // R[A] := sBx
```

Load a constant number sBx into the register R[A]. The range of sBx is [-2^16,
2^16).

## LoadK Instruction

```text
LoadK A Bx          // R[A] := K[Bx]
```

Load the constant of K[Bx] into the register R[A].

## AddI Instruction

```text
AddI A B sC         // R[A] := R[B] + sC
```

Add the value of the register R[B] and the constant number sC (positive if K
equals to 0, negative otherwise), and store the result into register R[A]. The
range of sC is [-255, 255]. AddI is often used to add a small value to a
register.

## Binary Operations

```text
AddK A B C          // R[A] := R[B] + K[C]
SubK A B C          // R[A] := R[B] - K[C]
MulK A B C          // R[A] := R[B] * K[C]
DivK A B C          // R[A] := R[B] / K[C]
```

```text
Add A B C           // R[A] := R[B] + R[C]
Sub A B C           // R[A] := R[B] - R[C]
Mul A B C           // R[A] := R[B] * R[C]
Div A B C           // R[A] := R[B] / R[C]
```

Perform the binary operators between the register R[B] and the constant K[C] or
register R[B]. The result of the operation is placed into R[A]. These
instructions are in the classic three address style.
